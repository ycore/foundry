{"version":3,"file":"auth-hash.js","sourceRoot":"","sources":["../../../../src/auth/utils/auth-hash.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,KAAK,EAAE,MAAM,8BAA8B,CAAC;AAE5F,MAAM,aAAa,GAAG;IACpB,UAAU,EAAE,GAAG;IACf,YAAY,EAAE,EAAE;IAChB,cAAc,EAAE,QAAQ;IACxB,aAAa,EAAE,SAAS;IACxB,UAAU,EAAE,MAAM;IAClB,UAAU,EAAE,EAAE;IACd,UAAU,EAAE,CAAC,CAAC;CACf,CAAC;AAEF,MAAM,CAAC,KAAK,UAAU,YAAY,CAAC,QAAgB;IACjD,MAAM,IAAI,GAAG,MAAM,kBAAkB,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;IAClE,MAAM,SAAS,GAAG,MAAM,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAErD,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,UAAU,CAAC,GAAG,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;AACpG,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,eAAe,CAAC,QAAgB,EAAE,cAAsB;IAC5E,MAAM,IAAI,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,UAAU,CAAC,GAAG,cAAc,CAAC,KAAK,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;IAChH,MAAM,YAAY,GAAG,cAAc,CAAC,KAAK,CAAC,aAAa,CAAC,UAAU,EAAE,aAAa,CAAC,UAAU,CAAC,CAAC;IAC9F,MAAM,SAAS,GAAG,MAAM,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAErD,OAAO,iBAAiB,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;AACpD,CAAC;AAED,KAAK,UAAU,YAAY,CAAC,IAAY,EAAE,QAAgB;IACxD,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;IAClC,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,aAAa,CAAC,cAAc,EAAE,KAAK,EAAE,CAAC,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC;IACjJ,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,UAAU,CAChD,EAAE,IAAI,EAAE,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,aAAa,CAAC,aAAa,EAAE,IAAI,EAAE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,aAAa,CAAC,UAAU,EAAE,EAC3I,OAAO,EACP,aAAa,CAAC,UAAU,CACzB,CAAC;IACF,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;IAEjE,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import { generateRandomSalt, timingSafeCompare, toHex } from '../../common/utils/crypto.js';\n\nconst HASH_DEFAULTS = {\n  BIT_LENGTH: 256,\n  BYTES_LENGTH: 16,\n  HASH_ALGORITHM: 'PBKDF2',\n  HASH_FUNCTION: 'SHA-256',\n  ITERATIONS: 100000,\n  PREFIX_POS: 24,\n  SUFFIX_POS: -8,\n};\n\nexport async function hashPassword(password: string): Promise<string> {\n  const salt = await generateRandomSalt(HASH_DEFAULTS.BYTES_LENGTH);\n  const hashedHex = await generateHash(salt, password);\n\n  return salt.slice(0, HASH_DEFAULTS.PREFIX_POS) + hashedHex + salt.slice(HASH_DEFAULTS.SUFFIX_POS);\n}\n\nexport async function comparePassword(password: string, hashedPassword: string): Promise<boolean> {\n  const salt = hashedPassword.slice(0, HASH_DEFAULTS.PREFIX_POS) + hashedPassword.slice(HASH_DEFAULTS.SUFFIX_POS);\n  const originalHash = hashedPassword.slice(HASH_DEFAULTS.PREFIX_POS, HASH_DEFAULTS.SUFFIX_POS);\n  const hashedHex = await generateHash(salt, password);\n\n  return timingSafeCompare(originalHash, hashedHex);\n}\n\nasync function generateHash(salt: string, password: string) {\n  const encoder = new TextEncoder();\n  const baseKey = await crypto.subtle.importKey('raw', encoder.encode(password), HASH_DEFAULTS.HASH_ALGORITHM, false, ['deriveBits', 'deriveKey']);\n  const derivedBits = await crypto.subtle.deriveBits(\n    { name: HASH_DEFAULTS.HASH_ALGORITHM, hash: HASH_DEFAULTS.HASH_FUNCTION, salt: encoder.encode(salt), iterations: HASH_DEFAULTS.ITERATIONS },\n    baseKey,\n    HASH_DEFAULTS.BIT_LENGTH\n  );\n  const hashedHex = toHex(Array.from(new Uint8Array(derivedBits)));\n\n  return hashedHex;\n}\n"]}