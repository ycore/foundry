{"version":3,"file":"index.js","sources":["../../../src/secure/csrf/server/csrf.ts","../../../src/secure/csrf/server/csrf.context.ts","../../../src/secure/csrf/server/csrf.context-helper.ts","../../../src/secure/csrf/server/csrf.middleware.ts","../../../src/secure/rate-limiter/server/providers/cloudflare-rate-limiter.ts","../../../src/secure/rate-limiter/server/providers/kv-rate-limiter.ts","../../../src/secure/rate-limiter/server/rate-limiter.provider.ts","../../../src/secure/rate-limiter/server/route-matcher.ts","../../../src/secure/rate-limiter/server/rate-limiter.middleware.ts"],"sourcesContent":["import { createCookie } from 'react-router';\nimport { CSRF } from 'remix-utils/csrf/server';\n\nimport type { CSRFConfig } from '../@types/csrf.types';\n\n/** Creates fresh CSRF instance with config (ensures request isolation) */\nexport function createCSRF(secret: string, config: CSRFConfig): CSRF {\n  const cookie = createCookie(config.cookieName, {\n    path: config.cookie.path,\n    httpOnly: config.cookie.httpOnly,\n    secure: config.cookie.secure,\n    sameSite: config.cookie.sameSite,\n    maxAge: config.cookie.maxAge,\n    secrets: [secret],\n  });\n\n  return new CSRF({\n    cookie,\n    secret,\n    formDataKey: 'csrf_token', // Hardcoded to match SecureForm default\n  });\n}\n","import { createContext } from 'react-router';\nimport type { CSRFData } from '../@types/csrf.types';\n\n/**\n * CSRF token context for server-side form protection\n * This is a React Router context used to pass CSRF data from middleware to loaders\n */\nexport const csrfContext = createContext<CSRFData | null>(null);\n\n/**\n * Context to skip CSRF validation for specific requests\n * Used for authenticated API routes or custom validation flows\n */\nexport const skipCSRFValidation = createContext<boolean>(false);\n","import { requireContext } from '@ycore/forge/context';\nimport type { AppLoadContext } from 'react-router';\nimport { csrfContext } from './csrf.context';\n\n/**\n * Require CSRF token from context\n * Throws Response(500) if middleware didn't run or token is missing\n *\n * @example\n * export const loader = async ({ context }) => {\n *   const token = requireCSRFToken(context);\n *   return { token };\n * };\n */\nexport function requireCSRFToken(context: AppLoadContext): string {\n  const csrfData = requireContext(context, csrfContext, {\n    errorMessage: 'CSRF protection not initialized - ensure createCSRFMiddleware() is configured for this route',\n    errorStatus: 500,\n  });\n\n  if (!csrfData.token) {\n    throw new Response('CSRF token generation failed', {\n      status: 500,\n      statusText: 'Internal Server Error',\n    });\n  }\n\n  return csrfData.token;\n}\n","import { setContext } from '@ycore/forge/context';\nimport { logger } from '@ycore/forge/logger';\nimport { middlewarePassthrough } from '@ycore/forge/result';\nimport { getBindings, isDevelopment } from '@ycore/forge/services';\nimport type { MiddlewareFunction } from 'react-router';\nimport type { CSRFConfig } from '../@types/csrf.types';\nimport { createCSRF } from './csrf';\nimport { csrfContext, skipCSRFValidation } from './csrf.context';\n\n/** Creates CSRF commit middleware (GET requests only) */\nexport function createCommitCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    // Only commit CSRF tokens for GET requests to avoid conflicts with validation\n    if (request.method !== 'GET') {\n      return next();\n    }\n\n    const bindings = getBindings(context);\n\n    if (!bindings) {\n      logger.error('csrf_bindings_not_available', { secretKey: config.secretKey });\n      throw new Error('Cloudflare bindings not available - context setup issue');\n    }\n\n    // Access the secret using bracket notation to ensure runtime safety\n    const secret = bindings[config.secretKey as keyof typeof bindings] as string | undefined;\n\n    if (!secret) {\n      logger.error('csrf_secret_not_found', { secretKey: config.secretKey, availableBindings: Object.keys(bindings) });\n      throw new Error(`CSRF secret binding '${config.secretKey}' not found in environment`);\n    }\n\n    // Override secure flag in development\n    const runtimeConfig = {\n      ...config,\n      cookie: {\n        ...config.cookie,\n        secure: isDevelopment(context) ? false : config.cookie.secure,\n      },\n    };\n\n    const csrf = createCSRF(secret, runtimeConfig);\n    const [token, cookieHeader] = await csrf.commitToken();\n\n    // Set token in context\n    const csrfData = { token };\n    setContext(context, csrfContext, csrfData);\n\n    const response = await next();\n\n    // Add CSRF cookie to response if needed\n    if (cookieHeader) {\n      return middlewarePassthrough(response, {\n        append: { 'Set-Cookie': cookieHeader },\n      });\n    }\n    return response;\n  };\n}\n\n/** Creates CSRF validation middleware (POST/PUT/DELETE/PATCH) */\nexport function createValidateCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    // Only process POST/PUT/DELETE requests\n    if (!['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {\n      return next();\n    }\n\n    // Check and skip CSRF validation for this request\n    const skipCSRF = context.get(skipCSRFValidation);\n    if (skipCSRF) {\n      setContext(context, skipCSRFValidation, false);\n      return next();\n    }\n\n    const bindings = getBindings(context);\n\n    // Error handling for missing bindings\n    if (!bindings) {\n      logger.error('csrf_bindings_not_available', { secretKey: config.secretKey });\n      throw new Error('Cloudflare bindings not available - context setup issue');\n    }\n\n    // Access the secret using bracket notation to ensure runtime safety\n    const secret = bindings[config.secretKey as keyof typeof bindings] as string | undefined;\n\n    if (!secret) {\n      logger.error('csrf_secret_not_found', { secretKey: config.secretKey, availableBindings: Object.keys(bindings) });\n      throw new Error(`CSRF secret binding '${config.secretKey}' not found in environment`);\n    }\n\n    // Override secure flag in development\n    const runtimeConfig = {\n      ...config,\n      cookie: {\n        ...config.cookie,\n        secure: isDevelopment(context) ? false : config.cookie.secure,\n      },\n    };\n\n    const csrf = createCSRF(secret, runtimeConfig);\n\n    try {\n      // Clone the request to read FormData without consuming original stream\n      const clonedRequest = request.clone();\n      const formData = await clonedRequest.formData();\n\n      await csrf.validate(formData, request.headers);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Token mismatch';\n      logger.error('csrf_validation_failed', { error: errorMessage, url: request.url });\n\n      throw new Response('Token mismatch', { status: 403, statusText: errorMessage });\n    }\n\n    return next();\n  };\n}\n\n/** Creates complete CSRF middleware (commit + validation) */\nexport function createCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response>[] {\n  return [createCommitCSRFMiddleware(config), createValidateCSRFMiddleware(config)];\n}\n","import type { Result } from '@ycore/forge/result';\nimport { err } from '@ycore/forge/result';\nimport { getBindings } from '@ycore/forge/services';\nimport type { RouterContextProvider } from 'react-router';\nimport type { CloudflareProviderConfig, CloudflareRateLimiterOptions, RateLimiterProvider, RateLimiterProviderConfig, RateLimitRequest, RateLimitResponse } from '../../@types/rate-limiter.types';\n\nconst DEFAULT_WINDOW_MS = 60 * 1000;\n\n/**\n * Type guard for Cloudflare rate limiter options\n */\nfunction isCloudflareRateLimiterOptions(options: unknown): options is CloudflareRateLimiterOptions {\n  return options != null && typeof options === 'object' && 'limiterBinding' in options && typeof (options as CloudflareRateLimiterOptions).limiterBinding === 'string';\n}\n\n/**\n * Cloudflare native rate limiting provider\n *\n * Rate limits are configured in wrangler.jsonc (infrastructure-level), not at runtime.\n *\n * Limitations (inherent to Cloudflare's API):\n * - Only returns success boolean (no granular remaining count)\n * - No built-in reset method (must wait for window expiration)\n * - Rate limits per-Cloudflare location (not globally consistent)\n *\n * @see https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/\n */\nexport const cloudflareRateLimiter: RateLimiterProvider = {\n  name: 'cloudflare',\n\n  async checkLimit(request: RateLimitRequest, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<RateLimitResponse>> {\n    // Type guard: Cloudflare provider config\n    if (config.type !== 'cloudflare') {\n      return err('Invalid provider type for Cloudflare rate limiter', {\n        expectedType: 'cloudflare',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const cfConfig = config as CloudflareProviderConfig;\n\n    // Type guard: Cloudflare rate limiter options\n    if (!isCloudflareRateLimiterOptions(cfConfig.options)) {\n      return err('Cloudflare rate limiter binding not configured', {\n        providerId: cfConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    const cfOptions = cfConfig.options;\n    const bindings = getBindings(context);\n    const rateLimiter = bindings[cfOptions.limiterBinding as keyof typeof bindings] as RateLimit | undefined;\n\n    if (!rateLimiter || typeof rateLimiter.limit !== 'function') {\n      return err(`RateLimit binding '${cfOptions.limiterBinding}' not found in Cloudflare bindings`, {\n        limiterBinding: cfOptions.limiterBinding,\n        providerId: config.id,\n        path: request.path,\n        identifier: request.identifier,\n        availableBindings: Object.keys(bindings),\n      });\n    }\n\n    try {\n      const key = `${request.path}:${request.identifier}`;\n\n      // Call Cloudflare's native rate limiting API\n      const outcome = await rateLimiter.limit({ key });\n\n      // Note: This is for response metadata only - actual limits are in wrangler.jsonc\n      const windowMs = DEFAULT_WINDOW_MS;\n\n      // Map Cloudflare's simple response to our RateLimitResponse interface\n      // Note: Cloudflare only provides success boolean, we approximate other fields\n      const response: RateLimitResponse = {\n        allowed: outcome.success,\n        remaining: outcome.success ? 1 : 0, // Return 1 if allowed (optimistic), 0 if blocked\n        resetAt: Date.now() + windowMs, // Approximate - Cloudflare doesn't expose exact reset time\n        retryAfter: outcome.success ? undefined : Math.ceil(windowMs / 1000), // Provide retryAfter in seconds when rate limited\n      };\n\n      return response;\n    } catch (error) {\n      return err(\n        'Failed to check Cloudflare rate limit',\n        {\n          limiterBinding: cfOptions.limiterBinding,\n          providerId: config.id,\n          key: `${request.path}:${request.identifier}`,\n          path: request.path,\n          identifier: request.identifier,\n        },\n        { cause: error }\n      );\n    }\n  },\n\n  /**\n   * Cloudflare's native Rate Limiting API does not provide a reset method\n   * Rate limits automatically expire based on the configured period\n   */\n  async resetLimit(identifier: string, config: RateLimiterProviderConfig, _context: Readonly<RouterContextProvider>): Promise<Result<void>> {\n    return err('Cloudflare rate limiter does not support manual reset', {\n      providerId: config.id,\n      identifier,\n      reason: 'Cloudflare Workers Rate Limiting API has no reset method - limits expire automatically based on configured period',\n      workaround: 'Wait for rate limit window to expire naturally, or use KV-based provider which supports resetLimit()',\n    });\n  },\n};\n","import type { Result } from '@ycore/forge/result';\nimport { err } from '@ycore/forge/result';\nimport { getKVStore } from '@ycore/forge/services';\nimport type { RouterContextProvider } from 'react-router';\nimport type { KvProviderConfig, KvRateLimiterOptions, RateLimiterProvider, RateLimiterProviderConfig, RateLimitMetadata, RateLimitRequest, RateLimitResponse } from '../../@types/rate-limiter.types';\n\nconst KV_MINIMUM_TTL = 60; // Cloudflare KV minimum TTL in seconds\nconst DEFAULT_RETRY_ATTEMPTS = 3; // Default retries for optimistic locking\nconst RETRY_DELAY_MS = 50; // Base delay between retries\nconst KV_KEY_PREFIX = 'rate_limit'; // Fixed prefix for KV namespace organization\n\nconst rateLimitKvTemplate = (path: string, identifier: string): string => `${KV_KEY_PREFIX}:${path}:${identifier}`;\n\n/**\n * Type guard for KV rate limiter options\n */\nfunction isKvRateLimiterOptions(options: unknown): options is KvRateLimiterOptions {\n  return options != null && typeof options === 'object' && 'kvBinding' in options && typeof (options as KvRateLimiterOptions).kvBinding === 'string';\n}\n\n/**\n * Type guard and validator for rate limit metadata\n */\nfunction isValidRateLimitMetadata(metadata: unknown): metadata is RateLimitMetadata {\n  if (metadata == null || typeof metadata !== 'object') {\n    return false;\n  }\n\n  const meta = metadata as RateLimitMetadata;\n  return typeof meta.count === 'number' && typeof meta.resetAt === 'number' && typeof meta.version === 'number' && meta.count >= 0 && meta.resetAt > 0 && meta.version >= 0;\n}\n\nexport const kvRateLimiter: RateLimiterProvider = {\n  name: 'kv',\n\n  async checkLimit(request: RateLimitRequest, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<RateLimitResponse>> {\n    // Type guard: Ensure this is a KV provider config\n    if (config.type !== 'kv') {\n      return err('Invalid provider type for KV rate limiter', {\n        expectedType: 'kv',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const kvConfig = config as KvProviderConfig;\n\n    // Validate KV binding configuration\n    if (!isKvRateLimiterOptions(kvConfig.options)) {\n      return err('KV binding not configured for rate limiting', {\n        providerId: kvConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    const kvOptions = kvConfig.options;\n\n    // Get the KV namespace from context using the configured binding\n    const kv = getKVStore(context, kvOptions.kvBinding);\n\n    if (!kv) {\n      return err(`KV namespace '${kvOptions.kvBinding}' not found in bindings`, {\n        kvBinding: kvOptions.kvBinding,\n        providerId: kvConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    // Extract limits from provider config\n    const maxRequests = kvConfig.limits.maxRequests;\n    const windowMs = kvConfig.limits.windowMs;\n    const maxRetries = kvConfig.behavior?.optimisticLockRetries ?? DEFAULT_RETRY_ATTEMPTS;\n\n    const key = rateLimitKvTemplate(request.path, request.identifier);\n    const now = Date.now();\n\n    /*\n     * IMPORTANT: KV-based rate limiting has inherent race condition risks\n     *\n     * Cloudflare KV is eventually consistent and does not support atomic operations.\n     * This implementation uses optimistic locking (version field) to reduce the race\n     * condition window from ~50ms to ~5ms, but cannot eliminate it completely.\n     *\n     * Current mitigation: Retry with version checking (best effort)\n     */\n\n    try {\n      let attempt = 0;\n      let lastError: Error | null = null;\n\n      while (attempt < maxRetries) {\n        attempt++;\n\n        try {\n          // Get current rate limit data with metadata\n          const kvValue = await kv.getWithMetadata<RateLimitMetadata>(key);\n          let metadata: RateLimitMetadata;\n          let previousVersion: number;\n\n          if (kvValue.metadata && isValidRateLimitMetadata(kvValue.metadata)) {\n            metadata = kvValue.metadata;\n            previousVersion = metadata.version;\n\n            // Check if window has expired\n            if (now >= metadata.resetAt) {\n              // Reset the window\n              metadata = {\n                count: 1,\n                resetAt: now + windowMs,\n                version: previousVersion + 1,\n              };\n            } else {\n              // Check if already blocked - skip write optimization (if enabled)\n              const skipWriteWhenBlocked = kvConfig.behavior?.skipWriteWhenBlocked ?? true;\n              if (skipWriteWhenBlocked && metadata.count > maxRequests) {\n                // Already exceeded limit, return without incrementing\n                const response: RateLimitResponse = {\n                  allowed: false,\n                  remaining: 0,\n                  resetAt: metadata.resetAt,\n                  retryAfter: Math.ceil((metadata.resetAt - now) / 1000),\n                };\n                return response;\n              }\n\n              // Increment counter\n              metadata = {\n                count: metadata.count + 1,\n                resetAt: metadata.resetAt,\n                version: previousVersion + 1,\n              };\n            }\n          } else {\n            // First request in window OR corrupted data - reset\n            metadata = {\n              count: 1,\n              resetAt: now + windowMs,\n              version: 1,\n            };\n            previousVersion = 0;\n          }\n\n          // Check if limit exceeded\n          const allowed = metadata.count <= maxRequests;\n          const remaining = Math.max(0, maxRequests - metadata.count);\n\n          // Store updated data with TTL using metadata API\n          const calculatedTtl = Math.ceil((metadata.resetAt - now) / 1000);\n          const ttl = Math.max(KV_MINIMUM_TTL, calculatedTtl);\n\n          // Use empty string as value, store data in metadata for performance\n          await kv.put(key, '', {\n            expirationTtl: ttl,\n            metadata: metadata,\n          });\n\n          // Verify version hasn't changed (optimistic locking check)\n          // Note: This is best-effort as KV doesn't guarantee consistency\n          const verifyValue = await kv.getWithMetadata<RateLimitMetadata>(key);\n          if (verifyValue.metadata && isValidRateLimitMetadata(verifyValue.metadata) && verifyValue.metadata.version !== metadata.version && verifyValue.metadata.version !== previousVersion) {\n            // Version conflict detected - retry\n            throw new Error('Version conflict detected - concurrent write');\n          }\n\n          const response: RateLimitResponse = {\n            allowed,\n            remaining,\n            resetAt: metadata.resetAt,\n            retryAfter: allowed ? undefined : Math.ceil((metadata.resetAt - now) / 1000),\n          };\n\n          return response;\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n\n          if (attempt < maxRetries) {\n            // Exponential backoff\n            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * attempt));\n            continue;\n          }\n\n          // Max retries exceeded\n          throw lastError;\n        }\n      }\n\n      // Should never reach here, but TypeScript needs it\n      throw lastError || new Error('Failed to check rate limit after retries');\n    } catch (error) {\n      return err(\n        'Failed to check rate limit',\n        {\n          key,\n          path: request.path,\n          identifier: request.identifier,\n          maxRequests,\n          windowMs,\n        },\n        { cause: error }\n      );\n    }\n  },\n\n  async resetLimit(identifier: string, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<void>> {\n    // Type guard: Ensure this is a KV provider config\n    if (config.type !== 'kv') {\n      return err('Invalid provider type for KV rate limiter', {\n        expectedType: 'kv',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const kvConfig = config as KvProviderConfig;\n\n    // Validate KV binding configuration\n    if (!isKvRateLimiterOptions(kvConfig.options)) {\n      return err('KV binding not configured for rate limiting', {\n        providerId: kvConfig.id,\n        identifier,\n      });\n    }\n\n    const kvOptions = kvConfig.options;\n\n    // Get the KV namespace from context using the configured binding\n    const kv = getKVStore(context, kvOptions.kvBinding);\n\n    if (!kv) {\n      return err(`KV namespace '${kvOptions.kvBinding}' not found in bindings`, {\n        kvBinding: kvOptions.kvBinding,\n        providerId: kvConfig.id,\n        identifier,\n      });\n    }\n\n    try {\n      // Find all rate limit keys for this identifier using KV list operations\n      let _deletedCount = 0;\n      let cursor: string | undefined;\n      let listComplete = false;\n\n      while (!listComplete) {\n        // List keys with pagination (using fixed KV prefix)\n        const listResult = await kv.list({ prefix: KV_KEY_PREFIX, cursor });\n\n        // Filter keys that match this identifier (keys end with :identifier)\n        const keysToDelete = listResult.keys.filter((keyInfo: { name: string }) => keyInfo.name.endsWith(`:${identifier}`)).map((keyInfo: { name: string }) => keyInfo.name);\n\n        // Delete matching keys in batch\n        await Promise.all(keysToDelete.map((key: string) => kv.delete(key)));\n\n        _deletedCount += keysToDelete.length;\n\n        // Check if pagination is complete\n        listComplete = listResult.list_complete;\n        cursor = listComplete ? undefined : listResult.keys[listResult.keys.length - 1]?.name;\n      }\n\n      // Return success (void)\n      return;\n    } catch (error) {\n      return err(\n        'Failed to reset rate limit',\n        {\n          identifier,\n          operation: 'resetLimit',\n        },\n        { cause: error }\n      );\n    }\n  },\n};\n","import type { Result } from '@ycore/forge/result';\nimport { err, isError } from '@ycore/forge/result';\nimport type { RouterContextProvider } from 'react-router';\nimport type { RateLimiterConfig, RateLimiterProvider, RateLimiterProviderConfig, RateLimitRequest, RateLimitResponse } from '../@types/rate-limiter.types';\nimport { cloudflareRateLimiter } from './providers/cloudflare-rate-limiter';\nimport { kvRateLimiter } from './providers/kv-rate-limiter';\n\n/**\n * Provider type registry\n * Maps provider type to implementation\n */\nconst rateLimiterProviders: Record<string, RateLimiterProvider> = {\n  kv: kvRateLimiter,\n  cloudflare: cloudflareRateLimiter,\n};\n\n/**\n * Get all configured provider IDs from config\n */\nfunction getRateLimiterProviderIds(config: RateLimiterConfig): string[] {\n  return config.providers.map(provider => provider.id);\n}\n\n/**\n * Get provider configuration by ID\n */\nexport function getProviderConfig(config: RateLimiterConfig, providerId: string): RateLimiterProviderConfig | null {\n  return config.providers.find(provider => provider.id === providerId) || null;\n}\n\n/**\n * Create a rate limiter provider instance by type\n */\nfunction createRateLimiterProvider(providerType: string): Result<RateLimiterProvider> {\n  const provider = rateLimiterProviders[providerType];\n\n  if (!provider) {\n    const availableProviders = Object.keys(rateLimiterProviders).join(', ');\n    return err(`Unknown rate limiter provider type: ${providerType}. Available: ${availableProviders}`);\n  }\n\n  return provider;\n}\n\n/**\n * Check rate limit using a specific provider (by ID)\n */\nexport async function checkRateLimit(config: RateLimiterConfig, request: RateLimitRequest, context: Readonly<RouterContextProvider>, providerId: string): Promise<Result<RateLimitResponse>> {\n  // Get provider configuration by ID\n  const providerConfig = getProviderConfig(config, providerId);\n  if (!providerConfig) {\n    return err(`Provider configuration not found for ID: ${providerId}`, {\n      providerId: providerId,\n      availableProviders: getRateLimiterProviderIds(config),\n    });\n  }\n\n  // Create provider instance by type\n  const providerResult = createRateLimiterProvider(providerConfig.type);\n  if (isError(providerResult)) {\n    return providerResult;\n  }\n\n  // Execute rate limit check\n  return await providerResult.checkLimit(request, providerConfig, context);\n}\n","import type { RateLimiterConfig, RateLimiterProviderConfig, RouteRateLimitConfig } from '../@types/rate-limiter.types';\n\n/**\n * Convert glob pattern to regex for route matching\n */\nfunction globToRegex(pattern: string): RegExp {\n  // First escape special regex characters except * and /\n  const escaped = pattern.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Then handle wildcards: ** for any depth, * for single segment\n  const regex = escaped\n    .replace(/\\*\\*/g, '___DOUBLE_STAR___') // Temporary placeholder\n    .replace(/\\*/g, '[^/]*') // Single * matches anything except /\n    .replace(/___DOUBLE_STAR___/g, '.*'); // ** matches anything including /\n  return new RegExp(`^${regex}$`);\n}\n\n/**\n * Check if a path matches a route pattern\n */\nfunction matchesRoute(path: string, pattern: string): boolean {\n  if (pattern === path) return true;\n  if (!pattern.includes('*')) return false;\n\n  const regex = globToRegex(pattern);\n  return regex.test(path);\n}\n\n/**\n * Find the most specific route configuration for a given path\n * Returns the route config with the longest matching pattern\n */\nfunction findRouteConfig(path: string, routes: RouteRateLimitConfig[]): RouteRateLimitConfig | null {\n  let bestMatch: RouteRateLimitConfig | null = null;\n  let bestMatchLength = 0;\n\n  for (const route of routes) {\n    if (matchesRoute(path, route.pattern)) {\n      // Prefer more specific patterns (longer non-wildcard parts)\n      const specificityScore = route.pattern.replace(/\\*/g, '').length;\n      if (specificityScore > bestMatchLength) {\n        bestMatch = route;\n        bestMatchLength = specificityScore;\n      }\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Get effective rate limit configuration for a specific request\n *\n * Rate limiting is applied to configured routes, null otherwise.\n */\nexport function getEffectiveRateLimitConfig(config: RateLimiterConfig, path: string, method: string): { providerConfig: RateLimiterProviderConfig; providerId: string } | null {\n  // Check if path should be skipped entirely\n  if (config.conditions?.skipPaths?.some(skipPath => matchesRoute(path, skipPath))) {\n    return null;\n  }\n\n  // Find route-specific configuration - only explicit routes are rate limited\n  const routeConfig = findRouteConfig(path, config.routes);\n\n  // No matching route = no rate limiting\n  if (!routeConfig) {\n    return null;\n  }\n\n  // Check if method is allowed for this specific route\n  if (routeConfig.methods && !routeConfig.methods.includes(method)) {\n    return null;\n  }\n\n  // Get provider configuration by ID\n  const providerId = routeConfig.provider;\n  const providerConfig = config.providers.find(p => p.id === providerId);\n\n  if (!providerConfig) {\n    // Provider not found - skip rate limiting for safety\n    return null;\n  }\n\n  // Return provider configuration\n  return { providerConfig, providerId };\n}\n","import { logger } from '@ycore/forge/logger';\nimport { getClientIP, isError } from '@ycore/forge/result';\nimport { data, type MiddlewareFunction } from 'react-router';\nimport type { KvProviderConfig, RateLimiterConfig } from '../@types/rate-limiter.types';\nimport { checkRateLimit } from './rate-limiter.provider';\nimport { getEffectiveRateLimitConfig } from './route-matcher';\n\n/**\n * Rate limiting middleware with intelligent route-based configuration - throws a 429 response when rate limit exceeded\n */\nexport function rateLimiterMiddleware(config: RateLimiterConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    const url = new URL(request.url);\n    const path = url.pathname;\n    const method = request.method;\n\n    // Get effective configuration for this request\n    const effectiveConfig = getEffectiveRateLimitConfig(config, path, method);\n\n    // Skip if no rate limiting should be applied\n    if (!effectiveConfig) {\n      return next();\n    }\n\n    // Create temporary config with effective settings for this request\n    const requestConfig = { ...config, providers: [effectiveConfig.providerConfig] };\n    const clientIP = getClientIP(request) || 'unknown';\n    const rateLimitRequest = { identifier: clientIP, path: path, method: method };\n    const rateLimitResult = await checkRateLimit(requestConfig, rateLimitRequest, context, effectiveConfig.providerId);\n\n    if (isError(rateLimitResult)) {\n      logger.error('Rate limit check (failed open)', { error: rateLimitResult.message });\n      // On error, allow the request through (fail open)\n      return next();\n    }\n\n    const { allowed, remaining, resetAt, retryAfter } = rateLimitResult;\n\n    // Get limit value based on provider type for headers\n    const limitHeader = effectiveConfig.providerConfig.type === 'kv' ? (effectiveConfig.providerConfig as KvProviderConfig).limits.maxRequests.toString() : '100';\n\n    if (!allowed) {\n      logger.warning('Rate limit exceeded', { path: rateLimitRequest.path, remaining, resetAt, retryAfter });\n\n      const headers: HeadersInit = {\n        'X-RateLimit-Limit': limitHeader,\n        'X-RateLimit-Remaining': remaining.toString(),\n        'X-RateLimit-Reset': Math.ceil(resetAt / 1000).toString(),\n      };\n\n      if (retryAfter) {\n        headers['Retry-After'] = retryAfter.toString();\n      }\n\n      // Throw response to ensure proper encoding\n      throw data({ message: 'Too many requests. Please try again later.', retryAfter }, { status: 429, headers });\n    }\n\n    const response = await next();\n\n    if (response instanceof Response) {\n      response.headers.set('X-RateLimit-Limit', limitHeader);\n      response.headers.set('X-RateLimit-Remaining', remaining.toString());\n      response.headers.set('X-RateLimit-Reset', Math.ceil(resetAt / 1000).toString());\n    }\n\n    return response;\n  };\n}\n"],"names":["response"],"mappings":"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"}