{
  "version": 3,
  "sources": ["../../src/secure/csrf/csrf.config.ts", "../../src/secure/csrf/csrf.context.tsx", "../../src/secure/csrf/csrf.middleware.ts", "../../src/secure/csrf/csrf.ts", "../../src/secure/csrf/form.tsx", "../../../../node_modules/clsx/dist/clsx.mjs", "../../src/secure/csrf/SecureFetcher.tsx", "../../src/secure/csrf/SecureForm.tsx", "../../src/secure/csrf/SecureProvider.tsx", "../../src/secure/rate-limiter/rate-limiter.config.ts", "../../src/secure/rate-limiter/rate-limiter.provider.ts", "../../src/secure/rate-limiter/providers/cloudflare-rate-limiter.ts", "../../src/secure/rate-limiter/providers/kv-rate-limiter.ts", "../../src/secure/index.ts"],
  "sourcesContent": [
    "import type { CSRFConfig } from './@types/csrf.types';\n\n/**\n * Default CSRF configuration\n * Can be overridden in app's config.system.ts\n */\nexport const defaultCSRFConfig: CSRFConfig = {\n  secretKey: 'UNCONFIGURED',\n  cookieName: '__csrf',\n  formDataKey: 'csrf_token',\n  headerName: 'x-csrf-token',\n  cookie: {\n    httpOnly: true,\n    sameSite: 'lax',\n    path: '/',\n    secure: true,\n    maxAge: undefined, // Session cookie by default\n  },\n};\n",
    "import { createContext, useContext } from 'react';\nimport type { CSRFData } from './@types/csrf.types';\nimport { defaultCSRFConfig } from './csrf.config';\n\n/**\n * Secure context provides CSRF token and configuration to client components\n */\nconst SecureContext = createContext<CSRFData | null>(null);\n\nexport const SecureContextProvider = SecureContext.Provider;\n\n/**\n * Access CSRF token and configuration\n * Returns token and field names needed for form submissions\n */\nexport function useSecureContext(): CSRFData {\n  const data = useContext(SecureContext);\n\n  // Fallback to defaults if provider not found\n  if (!data) {\n    return {\n      token: '',\n      formDataKey: defaultCSRFConfig.formDataKey,\n      headerName: defaultCSRFConfig.headerName,\n    };\n  }\n\n  return data;\n}\n",
    "import { logger } from '@ycore/forge/logger';\nimport { middlewarePassthrough } from '@ycore/forge/result';\nimport { getBindings, isDevelopment } from '@ycore/forge/services';\nimport { createContext, type MiddlewareFunction } from 'react-router';\nimport type { CSRFConfig, CSRFData } from './@types/csrf.types';\nimport { createCSRF } from './csrf';\n\n/** CSRF token context for form protection */\nexport const csrfContext = createContext<CSRFData | null>(null);\n\n/** Context to skip CSRF validation for specific requests */\nexport const skipCSRFValidation = createContext<boolean>(false);\n\n/** Creates CSRF commit middleware (GET requests only) */\nexport function createCommitCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    // Only commit CSRF tokens for GET requests to avoid conflicts with validation\n    if (request.method !== 'GET') {\n      return next();\n    }\n\n    const bindings = getBindings(context);\n\n    // Error handling for missing bindings\n    if (!bindings) {\n      logger.error('CSRF bindings not available', {\n        secretKey: config.secretKey\n      });\n      throw new Error('Cloudflare bindings not available - context setup issue');\n    }\n\n    // Access the secret using bracket notation to ensure runtime safety\n    const secret = bindings[config.secretKey as keyof typeof bindings] as string | undefined;\n\n    if (!secret) {\n      logger.error('CSRF secret not found in bindings', {\n        secretKey: config.secretKey,\n        availableBindings: Object.keys(bindings),\n        bindingsType: typeof bindings,\n        hasBindingsObject: !!bindings,\n        specificSecretType: typeof bindings[config.secretKey as keyof typeof bindings],\n      });\n      throw new Error(`CSRF secret binding '${config.secretKey}' not found in environment`);\n    }\n\n    // Override secure flag in development\n    const runtimeConfig = {\n      ...config,\n      cookie: {\n        ...config.cookie,\n        secure: isDevelopment(context) ? false : config.cookie.secure,\n      },\n    };\n\n    const csrf = createCSRF(secret, runtimeConfig);\n    const [token, cookieHeader] = await csrf.commitToken();\n\n    // Set both token and config in context\n    context.set(csrfContext, {\n      token,\n      formDataKey: config.formDataKey,\n      headerName: config.headerName,\n    });\n\n    const response = await next();\n\n    // Add CSRF cookie to response if needed\n    if (cookieHeader) {\n      return middlewarePassthrough(response, {\n        append: { 'Set-Cookie': cookieHeader },\n      });\n    }\n    return response;\n  };\n}\n\n/** Creates CSRF validation middleware (POST/PUT/DELETE/PATCH) */\nexport function createValidateCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    // Only process POST/PUT/DELETE requests\n    if (!['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {\n      return next();\n    }\n\n    // Check and skip CSRF validation for this request\n    const skipCSRF = context.get(skipCSRFValidation);\n    if (skipCSRF) {\n      context.set(skipCSRFValidation, false);\n      return next();\n    }\n\n    const bindings = getBindings(context);\n\n    // Error handling for missing bindings\n    if (!bindings) {\n      logger.error('CSRF bindings not available', {\n        secretKey: config.secretKey\n      });\n      throw new Error('Cloudflare bindings not available - context setup issue');\n    }\n\n    // Access the secret using bracket notation to ensure runtime safety\n    const secret = bindings[config.secretKey as keyof typeof bindings] as string | undefined;\n\n    if (!secret) {\n      logger.error('CSRF secret not found in bindings', {\n        secretKey: config.secretKey,\n        availableBindings: Object.keys(bindings),\n        bindingsType: typeof bindings,\n        hasBindingsObject: !!bindings,\n        specificSecretType: typeof bindings[config.secretKey as keyof typeof bindings],\n      });\n      throw new Error(`CSRF secret binding '${config.secretKey}' not found in environment`);\n    }\n\n    // Override secure flag in development\n    const runtimeConfig = {\n      ...config,\n      cookie: {\n        ...config.cookie,\n        secure: isDevelopment(context) ? false : config.cookie.secure,\n      },\n    };\n\n    const csrf = createCSRF(secret, runtimeConfig);\n\n    try {\n      // Clone the request to read FormData without consuming original stream\n      const clonedRequest = request.clone();\n      const formData = await clonedRequest.formData();\n\n      await csrf.validate(formData, request.headers);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Token mismatch';\n      const clonedFormData = await request.clone().formData();\n      const formDataKeys: string[] = [];\n      clonedFormData.forEach((_, key) => {\n        formDataKeys.push(key);\n      });\n\n      logger.error('CSRF validation failed', {\n        error: errorMessage,\n        url: request.url,\n        formDataKeys,\n        hasCsrfToken: clonedFormData.has(config.formDataKey),\n      });\n\n      throw new Response('Token mismatch', { status: 403, statusText: errorMessage });\n    }\n\n    return next();\n  };\n}\n\n/** Creates complete CSRF middleware (commit + validation) */\nexport function createCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response>[] {\n  return [createCommitCSRFMiddleware(config), createValidateCSRFMiddleware(config)];\n}\n",
    "import { createCookie } from 'react-router';\nimport { CSRF } from 'remix-utils/csrf/server';\n\nimport type { CSRFConfig } from './@types/csrf.types';\n\n/** Creates fresh CSRF instance with config (ensures request isolation) */\nexport function createCSRF(secret: string, config: CSRFConfig): CSRF {\n  const cookie = createCookie(config.cookieName, {\n    path: config.cookie.path,\n    httpOnly: config.cookie.httpOnly,\n    secure: config.cookie.secure,\n    sameSite: config.cookie.sameSite,\n    maxAge: config.cookie.maxAge,\n    secrets: [secret],\n  });\n\n  return new CSRF({\n    cookie,\n    secret,\n    formDataKey: config.formDataKey,\n  });\n}\n",
    "import { Label } from '@ycore/componentry/vibrant';\nimport clsx from 'clsx';\nimport React from 'react';\nimport type { FormErrorProps, FormFieldContextValue, FormFieldProps } from './@types/form.types';\n\nconst FormFieldContext = React.createContext<FormFieldContextValue | null>(null);\n\nexport { Form } from 'react-router';\n\nexport function FormField({ label, description, error, className, children }: FormFieldProps) {\n  const id = React.useId();\n  const fieldId = `${id}-field`;\n  const descriptionId = `${id}-description`;\n  const errorId = `${id}-error`;\n  const hasError = Boolean(error);\n\n  const contextValue = React.useMemo(() => ({ fieldId, descriptionId, errorId, hasError }), [fieldId, descriptionId, errorId, hasError]);\n\n  const enhancedChildren = React.Children.map(children, child => {\n    if (!React.isValidElement(child)) return child;\n\n    const childProps = child.props as any;\n    if (childProps.name) {\n      const ariaDescribedBy = [description && descriptionId, error && errorId].filter(Boolean).join(' ') || undefined;\n\n      return React.cloneElement(child as React.ReactElement<any>, {\n        id: childProps.id || fieldId,\n        'aria-invalid': hasError || undefined,\n        'aria-describedby': ariaDescribedBy,\n        'data-error': hasError || undefined,\n      });\n    }\n\n    return child;\n  });\n\n  return (\n    <FormFieldContext.Provider value={contextValue}>\n      <div className={className} data-slot=\"form-field\">\n        {label && (\n          <Label htmlFor={fieldId} data-slot=\"form-label\" data-error={hasError} className={clsx(hasError && 'text-destructive')}>\n            {label}\n          </Label>\n        )}\n\n        {enhancedChildren}\n\n        {description && !error && (\n          <p id={descriptionId} data-slot=\"form-description\" className=\"text-muted-foreground text-sm\">\n            {description}\n          </p>\n        )}\n\n        {error && <FormError id={errorId} error={error} />}\n      </div>\n    </FormFieldContext.Provider>\n  );\n}\n\nexport function FormError({ error, className, id }: FormErrorProps) {\n  if (!error) {\n    return null;\n  }\n\n  return (\n    <p id={id} data-slot=\"form-error\" className={clsx('text-destructive text-sm', className)}>\n      {error}\n    </p>\n  );\n}\n\nexport function useFormField() {\n  const context = React.useContext(FormFieldContext);\n\n  if (!context) {\n    throw new Error('useFormField must be used within a FormField');\n  }\n\n  return context;\n}\n",
    "function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;",
    "import type { FieldErrors } from '@ycore/forge/result';\nimport { extractFieldErrors, isError } from '@ycore/forge/result';\nimport clsx from 'clsx';\nimport React from 'react';\nimport { type FetcherWithComponents, type SubmitOptions, useFetcher } from 'react-router';\nimport { AuthenticityTokenInput } from 'remix-utils/csrf/react';\nimport { useSecureContext } from './csrf.context';\n\n// Types\nexport interface SecureFetcherFormProps extends Omit<React.ComponentProps<'form'>, 'method' | 'action' | 'encType'> {\n  /** Override the CSRF token field name (optional) */\n  csrf_name?: string;\n  errors?: FieldErrors | null;\n  fetcher: FetcherWithComponents<unknown>;\n  children?: React.ReactNode;\n  method?: 'get' | 'post' | 'put' | 'patch' | 'delete';\n  action?: string;\n  encType?: 'application/x-www-form-urlencoded' | 'multipart/form-data' | 'text/plain';\n}\n\nexport interface UseSecureFetcherOptions {\n  key?: string;\n}\n\nexport interface SecureFetcherHandle<T = unknown> {\n  SecureForm: React.FC<Omit<SecureFetcherFormProps, 'fetcher'>>;\n  submitSecure: (data: FormData, options?: SubmitOptions) => void;\n  errors: FieldErrors | null;\n  data: T | undefined;\n  state: 'idle' | 'submitting' | 'loading';\n  Form: FetcherWithComponents<T>['Form'];\n  submit: FetcherWithComponents<T>['submit'];\n  load: FetcherWithComponents<T>['load'];\n  formData: FormData | undefined;\n  formMethod: 'get' | 'post' | 'put' | 'patch' | 'delete' | undefined;\n  formAction: string | undefined;\n  formEncType: 'application/x-www-form-urlencoded' | 'multipart/form-data' | 'application/json' | 'text/plain' | undefined;\n}\n\n/** Fetcher with built-in CSRF protection */\nexport function useSecureFetcher<T = unknown>({ key }: UseSecureFetcherOptions = {}): SecureFetcherHandle<T> {\n  const fetcher = useFetcher<T>({ key });\n  const csrfData = useSecureContext();\n\n  // Extract errors from fetcher data if present\n  const errors = React.useMemo(() => {\n    if (fetcher.data && isError(fetcher.data)) {\n      return extractFieldErrors(fetcher.data);\n    }\n    return null;\n  }, [fetcher.data]);\n\n  // Secure submit function that automatically adds CSRF token\n  const submitSecure = React.useCallback(\n    (data: FormData, options?: SubmitOptions) => {\n      const secureData = new FormData();\n\n      // Copy all existing form data\n      data.forEach((value, key) => {\n        secureData.append(key, value);\n      });\n\n      // Add CSRF token if not already present using configured field name\n      if (!secureData.has(csrfData.formDataKey) && csrfData.token) {\n        secureData.append(csrfData.formDataKey, csrfData.token);\n      }\n\n      fetcher.submit(secureData, options);\n    },\n    [fetcher, csrfData.token, csrfData.formDataKey]\n  );\n\n  // SecureForm component bound to this fetcher\n  const SecureForm = React.useMemo(\n    () =>\n      React.forwardRef<HTMLFormElement, Omit<SecureFetcherFormProps, 'fetcher'>>(({ children, csrf_name, errors: explicitErrors, ...props }, ref) => (\n        <SecureFetcherForm ref={ref} fetcher={fetcher} csrf_name={csrf_name} errors={explicitErrors || errors} {...props}>\n          {children}\n        </SecureFetcherForm>\n      )),\n    [fetcher, errors]\n  );\n\n  SecureForm.displayName = 'SecureForm';\n\n  return {\n    SecureForm,\n    submitSecure,\n    errors,\n    data: fetcher.data as T | undefined,\n    state: fetcher.state,\n    Form: fetcher.Form,\n    submit: fetcher.submit,\n    load: fetcher.load,\n    formData: fetcher.formData,\n    formMethod: fetcher.formMethod?.toLowerCase() as 'get' | 'post' | 'put' | 'patch' | 'delete' | undefined,\n    formAction: fetcher.formAction,\n    formEncType: fetcher.formEncType,\n  };\n}\n\n/** Fetcher form with CSRF protection */\nexport const SecureFetcherForm = React.forwardRef<HTMLFormElement, SecureFetcherFormProps>(({ children, csrf_name, errors, fetcher, className, ...props }, ref) => {\n  const csrfData = useSecureContext();\n\n  // Use override if provided, otherwise use config value\n  const tokenFieldName = csrf_name ?? csrfData.formDataKey;\n  const FetcherForm = fetcher.Form;\n\n  return (\n    <FetcherForm ref={ref} className={className} {...props}>\n      {/* CSRF token hidden input */}\n      <AuthenticityTokenInput name={tokenFieldName} />\n\n      {/* Display CSRF validation error if present */}\n      {errors?.csrf && <SecureFetcherError error={errors.csrf} className=\"mb-4\" />}\n\n      {/* Display general form error if present (and no CSRF error) */}\n      {errors?.form && !errors.csrf && <SecureFetcherError error={errors.form} className=\"mb-4\" />}\n\n      {children}\n    </FetcherForm>\n  );\n});\n\nSecureFetcherForm.displayName = 'SecureFetcherForm';\n\n/** Displays fetcher error messages */\nexport function SecureFetcherError({ error, className, id }: { error?: string | null; className?: string; id?: string }) {\n  if (!error) {\n    return null;\n  }\n\n  return (\n    <p id={id} data-slot=\"form-error\" className={clsx('text-destructive text-sm', className)} role=\"alert\">\n      {error}\n    </p>\n  );\n}\n\n/** Field component for fetcher forms (reuses SecureFormField) */\nexport { SecureFormField as SecureFetcherField } from './SecureForm';\n\n/** Creates field props with error handling for fetchers */\nexport function createFetcherFieldProps(name: string, errors?: FieldErrors | null): { error?: string; 'aria-invalid'?: boolean; 'aria-describedby'?: string } {\n  const error = errors?.[name];\n\n  if (!error) {\n    return {};\n  }\n\n  return { error, 'aria-invalid': true, 'aria-describedby': `${name}-error` };\n}\n",
    "import { Label } from '@ycore/componentry/vibrant';\nimport type { FieldErrors } from '@ycore/forge/result';\nimport clsx from 'clsx';\nimport React from 'react';\nimport { Form } from 'react-router';\nimport { AuthenticityTokenInput } from 'remix-utils/csrf/react';\nimport { useSecureContext } from './csrf.context';\n\n// Types\nexport interface SecureFormProps extends React.ComponentProps<typeof Form> {\n  /** Override the CSRF token field name (optional) */\n  csrf_name?: string;\n  /** Form-level and field-level errors */\n  errors?: FieldErrors | null;\n  children?: React.ReactNode;\n}\n\nexport interface SecureFormFieldProps {\n  name: string;\n  label?: string;\n  description?: string;\n  error?: string | null;\n  required?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n}\n\nexport interface SecureFormErrorProps {\n  error?: string | null;\n  className?: string;\n  id?: string;\n}\n\n// Context for passing errors down to field components\nconst SecureFormContext = React.createContext<{ errors: FieldErrors | null }>({ errors: null });\n\n/** Form with CSRF protection and error handling */\nexport function SecureForm({ children, csrf_name, errors, ...props }: SecureFormProps) {\n  const csrfData = useSecureContext();\n\n  // Use override if provided, otherwise use config value\n  const tokenFieldName = csrf_name ?? csrfData.formDataKey;\n  const contextValue = React.useMemo(() => ({ errors: errors || null }), [errors]);\n\n  return (\n    <SecureFormContext.Provider value={contextValue}>\n      <Form role=\"form\" {...props}>\n        {/* CSRF token hidden input - uses configured field name - only render if token exists */}\n        {csrfData.token && <AuthenticityTokenInput name={tokenFieldName} />}\n\n        {/* Display CSRF validation error if present */}\n        {errors?.csrf && <SecureFormError error={errors.csrf} className=\"mb-4\" />}\n\n        {/* Display general form error if present (and no CSRF error) */}\n        {errors?.form && !errors.csrf && <SecureFormError error={errors.form} className=\"mb-4\" />}\n\n        {children}\n      </Form>\n    </SecureFormContext.Provider>\n  );\n}\n\n/** Form field with automatic error display and ARIA attributes */\nexport function SecureFormField({ name, label, description, error, required, className, children }: SecureFormFieldProps) {\n  const { errors } = React.useContext(SecureFormContext);\n  const fieldError = error || errors?.[name];\n  const errorId = fieldError ? `${name}-error` : undefined;\n\n  return (\n    <div className={clsx('space-y-2', className)}>\n      {label && (\n        <Label htmlFor={name}>\n          {label}\n          {required && <span className=\"ml-1 text-destructive\">*</span>}\n        </Label>\n      )}\n      {description && <p className=\"text-muted-foreground text-sm\">{description}</p>}\n      {React.Children.map(children, child => {\n        if (React.isValidElement(child)) {\n          return React.cloneElement(child as React.ReactElement<any>, {\n            id: (child.props as any).id || name,\n            name: (child.props as any).name || name,\n            'aria-invalid': fieldError ? true : undefined,\n            'aria-describedby': fieldError ? errorId : (child.props as any)['aria-describedby'],\n          });\n        }\n        return child;\n      })}\n      {fieldError && (\n        <p id={errorId} className=\"text-destructive text-sm\" role=\"alert\">\n          {fieldError}\n        </p>\n      )}\n    </div>\n  );\n}\n\n/** Displays form-level error messages */\nexport function SecureFormError({ error, className, id }: SecureFormErrorProps) {\n  if (!error) {\n    return null;\n  }\n\n  return (\n    <p id={id} data-slot=\"form-error\" className={clsx('text-destructive text-sm', className)} role=\"alert\">\n      {error}\n    </p>\n  );\n}\n\n/** Returns form field props with error handling */\nexport function useSecureFormField(name: string): { error?: string; 'aria-invalid'?: boolean; 'aria-describedby'?: string } {\n  const { errors } = React.useContext(SecureFormContext);\n  const error = errors?.[name];\n\n  if (!error) {\n    return {};\n  }\n\n  return {\n    error,\n    'aria-invalid': true,\n    'aria-describedby': `${name}-error`,\n  };\n}\n",
    "import type { ReactNode } from 'react';\nimport { AuthenticityTokenProvider } from 'remix-utils/csrf/react';\nimport type { CSRFData } from './@types/csrf.types';\nimport { SecureContextProvider } from './csrf.context';\n\nexport interface SecureProviderProps {\n  children: ReactNode;\n  csrfData: CSRFData | null;\n}\n\n/** Provides CSRF protection with unified context */\nexport const SecureProvider = ({ children, csrfData }: SecureProviderProps) => {\n  const token = csrfData?.token ?? '';\n\n  return (\n    <SecureContextProvider value={csrfData}>\n      <AuthenticityTokenProvider token={token}>{children}</AuthenticityTokenProvider>\n    </SecureContextProvider>\n  );\n};\n",
    "import type { CloudflareProviderConfig, KvProviderConfig, RateLimiterConfig } from './@types/rate-limiter.types';\n\n/**\n * Default rate limiter configuration\n *\n * IMPORTANT: This configuration uses 'UNCONFIGURED' placeholders that MUST be\n * replaced by the consuming application in config.system.ts\n *\n * The app is responsible for:\n * - Configuring kvBinding to match a KV namespace from wrangler.jsonc\n * - Configuring limiterBinding to match a RateLimit binding from wrangler.jsonc\n * - Defining explicit route configurations with provider assignments\n *\n * Rate limiting is ONLY applied to routes explicitly configured in the routes array.\n */\nexport const defaultRateLimiterConfig: RateLimiterConfig = {\n  providers: [\n    {\n      id: 'default-kv',\n      type: 'kv',\n      options: {\n        kvBinding: 'UNCONFIGURED',\n      },\n      limits: {\n        maxRequests: 10,\n        windowMs: 60 * 1000, // 1 minute window\n      },\n    } satisfies KvProviderConfig,\n    {\n      id: 'default-cloudflare',\n      type: 'cloudflare',\n      options: {\n        limiterBinding: 'UNCONFIGURED',\n      },\n    } satisfies CloudflareProviderConfig,\n  ],\n  routes: [\n    // Example route configuration (uncomment and customize as needed):\n    // {\n    //   pattern: '/api/**',\n    //   provider: 'default-kv',\n    //   methods: ['POST', 'PUT', 'DELETE', 'PATCH'],\n    // },\n  ],\n  conditions: {\n    skipPaths: ['/favicon.ico'],\n  },\n};\n",
    "import type { Result } from '@ycore/forge/result';\nimport { err, isError } from '@ycore/forge/result';\nimport type { RouterContextProvider } from 'react-router';\nimport type { RateLimiterConfig, RateLimiterProvider, RateLimiterProviderConfig, RateLimitRequest, RateLimitResponse } from './@types/rate-limiter.types';\nimport { cloudflareRateLimiter } from './providers/cloudflare-rate-limiter';\nimport { kvRateLimiter } from './providers/kv-rate-limiter';\n\n/**\n * Provider type registry\n * Maps provider type to implementation\n */\nconst rateLimiterProviders: Record<string, RateLimiterProvider> = {\n  kv: kvRateLimiter,\n  cloudflare: cloudflareRateLimiter,\n};\n\n/**\n * Get all configured provider IDs from config\n */\nfunction getRateLimiterProviderIds(config: RateLimiterConfig): string[] {\n  return config.providers.map(provider => provider.id);\n}\n\n/**\n * Get provider configuration by ID\n */\nexport function getProviderConfig(config: RateLimiterConfig, providerId: string): RateLimiterProviderConfig | null {\n  return config.providers.find(provider => provider.id === providerId) || null;\n}\n\n/**\n * Create a rate limiter provider instance by type\n */\nfunction createRateLimiterProvider(providerType: string): Result<RateLimiterProvider> {\n  const provider = rateLimiterProviders[providerType];\n\n  if (!provider) {\n    const availableProviders = Object.keys(rateLimiterProviders).join(', ');\n    return err(`Unknown rate limiter provider type: ${providerType}. Available: ${availableProviders}`);\n  }\n\n  return provider;\n}\n\n/**\n * Check rate limit using a specific provider (by ID)\n */\nexport async function checkRateLimit(config: RateLimiterConfig, request: RateLimitRequest, context: Readonly<RouterContextProvider>, providerId: string): Promise<Result<RateLimitResponse>> {\n  // Get provider configuration by ID\n  const providerConfig = getProviderConfig(config, providerId);\n  if (!providerConfig) {\n    return err(`Provider configuration not found for ID: ${providerId}`, {\n      providerId: providerId,\n      availableProviders: getRateLimiterProviderIds(config),\n    });\n  }\n\n  // Create provider instance by type\n  const providerResult = createRateLimiterProvider(providerConfig.type);\n  if (isError(providerResult)) {\n    return providerResult;\n  }\n\n  // Execute rate limit check\n  return await providerResult.checkLimit(request, providerConfig, context);\n}\n",
    "import type { Result } from '@ycore/forge/result';\nimport { err } from '@ycore/forge/result';\nimport { getBindings } from '@ycore/forge/services';\nimport type { RouterContextProvider } from 'react-router';\nimport type { CloudflareProviderConfig, CloudflareRateLimiterOptions, RateLimiterProvider, RateLimiterProviderConfig, RateLimitRequest, RateLimitResponse } from '../@types/rate-limiter.types';\n\nconst DEFAULT_WINDOW_MS = 60 * 1000;\n\n/**\n * Type guard for Cloudflare rate limiter options\n */\nfunction isCloudflareRateLimiterOptions(options: unknown): options is CloudflareRateLimiterOptions {\n  return options != null && typeof options === 'object' && 'limiterBinding' in options && typeof (options as CloudflareRateLimiterOptions).limiterBinding === 'string';\n}\n\n/**\n * Cloudflare native rate limiting provider\n *\n * Rate limits are configured in wrangler.jsonc (infrastructure-level), not at runtime.\n *\n * Limitations (inherent to Cloudflare's API):\n * - Only returns success boolean (no granular remaining count)\n * - No built-in reset method (must wait for window expiration)\n * - Rate limits per-Cloudflare location (not globally consistent)\n *\n * @see https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/\n */\nexport const cloudflareRateLimiter: RateLimiterProvider = {\n  name: 'cloudflare',\n\n  async checkLimit(request: RateLimitRequest, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<RateLimitResponse>> {\n    // Type guard: Cloudflare provider config\n    if (config.type !== 'cloudflare') {\n      return err('Invalid provider type for Cloudflare rate limiter', {\n        expectedType: 'cloudflare',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const cfConfig = config as CloudflareProviderConfig;\n\n    // Type guard: Cloudflare rate limiter options\n    if (!isCloudflareRateLimiterOptions(cfConfig.options)) {\n      return err('Cloudflare rate limiter binding not configured', {\n        providerId: cfConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    const cfOptions = cfConfig.options;\n    const bindings = getBindings(context);\n    const rateLimiter = bindings[cfOptions.limiterBinding as keyof typeof bindings] as RateLimit | undefined;\n\n    if (!rateLimiter || typeof rateLimiter.limit !== 'function') {\n      return err(`RateLimit binding '${cfOptions.limiterBinding}' not found in Cloudflare bindings`, {\n        limiterBinding: cfOptions.limiterBinding,\n        providerId: config.id,\n        path: request.path,\n        identifier: request.identifier,\n        availableBindings: Object.keys(bindings),\n      });\n    }\n\n    try {\n      const key = `${request.path}:${request.identifier}`;\n\n      // Call Cloudflare's native rate limiting API\n      const outcome = await rateLimiter.limit({ key });\n\n      // Note: This is for response metadata only - actual limits are in wrangler.jsonc\n      const windowMs = DEFAULT_WINDOW_MS;\n\n      // Map Cloudflare's simple response to our RateLimitResponse interface\n      // Note: Cloudflare only provides success boolean, we approximate other fields\n      const response: RateLimitResponse = {\n        allowed: outcome.success,\n        remaining: outcome.success ? 1 : 0, // Return 1 if allowed (optimistic), 0 if blocked\n        resetAt: Date.now() + windowMs, // Approximate - Cloudflare doesn't expose exact reset time\n        retryAfter: outcome.success ? undefined : Math.ceil(windowMs / 1000), // Provide retryAfter in seconds when rate limited\n      };\n\n      return response;\n    } catch (error) {\n      return err(\n        'Failed to check Cloudflare rate limit',\n        {\n          limiterBinding: cfOptions.limiterBinding,\n          providerId: config.id,\n          key: `${request.path}:${request.identifier}`,\n          path: request.path,\n          identifier: request.identifier,\n        },\n        { cause: error }\n      );\n    }\n  },\n\n  /**\n   * Cloudflare's native Rate Limiting API does not provide a reset method\n   * Rate limits automatically expire based on the configured period\n   */\n  async resetLimit(identifier: string, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<void>> {\n    return err('Cloudflare rate limiter does not support manual reset', {\n      providerId: config.id,\n      identifier,\n      reason: 'Cloudflare Workers Rate Limiting API has no reset method - limits expire automatically based on configured period',\n      workaround: 'Wait for rate limit window to expire naturally, or use KV-based provider which supports resetLimit()',\n    });\n  },\n};\n",
    "import type { Result } from '@ycore/forge/result';\nimport { err } from '@ycore/forge/result';\nimport { getKVStore } from '@ycore/forge/services';\nimport type { RouterContextProvider } from 'react-router';\nimport type { KvProviderConfig, KvRateLimiterOptions, RateLimiterProvider, RateLimiterProviderConfig, RateLimitMetadata, RateLimitRequest, RateLimitResponse } from '../@types/rate-limiter.types';\n\nconst KV_MINIMUM_TTL = 60; // Cloudflare KV minimum TTL in seconds\nconst DEFAULT_RETRY_ATTEMPTS = 3; // Default retries for optimistic locking\nconst RETRY_DELAY_MS = 50; // Base delay between retries\nconst KV_KEY_PREFIX = 'rate_limit'; // Fixed prefix for KV namespace organization\n\nconst rateLimitKvTemplate = (path: string, identifier: string): string => `${KV_KEY_PREFIX}:${path}:${identifier}`;\n\n/**\n * Type guard for KV rate limiter options\n */\nfunction isKvRateLimiterOptions(options: unknown): options is KvRateLimiterOptions {\n  return options != null && typeof options === 'object' && 'kvBinding' in options && typeof (options as KvRateLimiterOptions).kvBinding === 'string';\n}\n\n/**\n * Type guard and validator for rate limit metadata\n */\nfunction isValidRateLimitMetadata(metadata: unknown): metadata is RateLimitMetadata {\n  if (metadata == null || typeof metadata !== 'object') {\n    return false;\n  }\n\n  const meta = metadata as RateLimitMetadata;\n  return typeof meta.count === 'number' && typeof meta.resetAt === 'number' && typeof meta.version === 'number' && meta.count >= 0 && meta.resetAt > 0 && meta.version >= 0;\n}\n\nexport const kvRateLimiter: RateLimiterProvider = {\n  name: 'kv',\n\n  async checkLimit(request: RateLimitRequest, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<RateLimitResponse>> {\n    // Type guard: Ensure this is a KV provider config\n    if (config.type !== 'kv') {\n      return err('Invalid provider type for KV rate limiter', {\n        expectedType: 'kv',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const kvConfig = config as KvProviderConfig;\n\n    // Validate KV binding configuration\n    if (!isKvRateLimiterOptions(kvConfig.options)) {\n      return err('KV binding not configured for rate limiting', {\n        providerId: kvConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    const kvOptions = kvConfig.options;\n\n    // Get the KV namespace from context using the configured binding\n    const kv = getKVStore(context, kvOptions.kvBinding);\n\n    if (!kv) {\n      return err(`KV namespace '${kvOptions.kvBinding}' not found in bindings`, {\n        kvBinding: kvOptions.kvBinding,\n        providerId: kvConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    // Extract limits from provider config\n    const maxRequests = kvConfig.limits.maxRequests;\n    const windowMs = kvConfig.limits.windowMs;\n    const maxRetries = kvConfig.behavior?.optimisticLockRetries ?? DEFAULT_RETRY_ATTEMPTS;\n\n    const key = rateLimitKvTemplate(request.path, request.identifier);\n    const now = Date.now();\n\n    /*\n     * IMPORTANT: KV-based rate limiting has inherent race condition risks\n     *\n     * Cloudflare KV is eventually consistent and does not support atomic operations.\n     * This implementation uses optimistic locking (version field) to reduce the race\n     * condition window from ~50ms to ~5ms, but cannot eliminate it completely.\n     *\n     * Current mitigation: Retry with version checking (best effort)\n     */\n\n    try {\n      let attempt = 0;\n      let lastError: Error | null = null;\n\n      while (attempt < maxRetries) {\n        attempt++;\n\n        try {\n          // Get current rate limit data with metadata\n          const kvValue = await kv.getWithMetadata<RateLimitMetadata>(key);\n          let metadata: RateLimitMetadata;\n          let previousVersion: number;\n\n          if (kvValue.metadata && isValidRateLimitMetadata(kvValue.metadata)) {\n            metadata = kvValue.metadata;\n            previousVersion = metadata.version;\n\n            // Check if window has expired\n            if (now >= metadata.resetAt) {\n              // Reset the window\n              metadata = {\n                count: 1,\n                resetAt: now + windowMs,\n                version: previousVersion + 1,\n              };\n            } else {\n              // Check if already blocked - skip write optimization (if enabled)\n              const skipWriteWhenBlocked = kvConfig.behavior?.skipWriteWhenBlocked ?? true;\n              if (skipWriteWhenBlocked && metadata.count > maxRequests) {\n                // Already exceeded limit, return without incrementing\n                const response: RateLimitResponse = {\n                  allowed: false,\n                  remaining: 0,\n                  resetAt: metadata.resetAt,\n                  retryAfter: Math.ceil((metadata.resetAt - now) / 1000),\n                };\n                return response;\n              }\n\n              // Increment counter\n              metadata = {\n                count: metadata.count + 1,\n                resetAt: metadata.resetAt,\n                version: previousVersion + 1,\n              };\n            }\n          } else {\n            // First request in window OR corrupted data - reset\n            metadata = {\n              count: 1,\n              resetAt: now + windowMs,\n              version: 1,\n            };\n            previousVersion = 0;\n          }\n\n          // Check if limit exceeded\n          const allowed = metadata.count <= maxRequests;\n          const remaining = Math.max(0, maxRequests - metadata.count);\n\n          // Store updated data with TTL using metadata API\n          const calculatedTtl = Math.ceil((metadata.resetAt - now) / 1000);\n          const ttl = Math.max(KV_MINIMUM_TTL, calculatedTtl);\n\n          // Use empty string as value, store data in metadata for performance\n          await kv.put(key, '', {\n            expirationTtl: ttl,\n            metadata: metadata,\n          });\n\n          // Verify version hasn't changed (optimistic locking check)\n          // Note: This is best-effort as KV doesn't guarantee consistency\n          const verifyValue = await kv.getWithMetadata<RateLimitMetadata>(key);\n          if (verifyValue.metadata && isValidRateLimitMetadata(verifyValue.metadata) && verifyValue.metadata.version !== metadata.version && verifyValue.metadata.version !== previousVersion) {\n            // Version conflict detected - retry\n            throw new Error('Version conflict detected - concurrent write');\n          }\n\n          const response: RateLimitResponse = {\n            allowed,\n            remaining,\n            resetAt: metadata.resetAt,\n            retryAfter: allowed ? undefined : Math.ceil((metadata.resetAt - now) / 1000),\n          };\n\n          return response;\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n\n          if (attempt < maxRetries) {\n            // Exponential backoff\n            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * attempt));\n            continue;\n          }\n\n          // Max retries exceeded\n          throw lastError;\n        }\n      }\n\n      // Should never reach here, but TypeScript needs it\n      throw lastError || new Error('Failed to check rate limit after retries');\n    } catch (error) {\n      return err(\n        'Failed to check rate limit',\n        {\n          key,\n          path: request.path,\n          identifier: request.identifier,\n          maxRequests,\n          windowMs,\n        },\n        { cause: error }\n      );\n    }\n  },\n\n  async resetLimit(identifier: string, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<void>> {\n    // Type guard: Ensure this is a KV provider config\n    if (config.type !== 'kv') {\n      return err('Invalid provider type for KV rate limiter', {\n        expectedType: 'kv',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const kvConfig = config as KvProviderConfig;\n\n    // Validate KV binding configuration\n    if (!isKvRateLimiterOptions(kvConfig.options)) {\n      return err('KV binding not configured for rate limiting', {\n        providerId: kvConfig.id,\n        identifier,\n      });\n    }\n\n    const kvOptions = kvConfig.options;\n\n    // Get the KV namespace from context using the configured binding\n    const kv = getKVStore(context, kvOptions.kvBinding);\n\n    if (!kv) {\n      return err(`KV namespace '${kvOptions.kvBinding}' not found in bindings`, {\n        kvBinding: kvOptions.kvBinding,\n        providerId: kvConfig.id,\n        identifier,\n      });\n    }\n\n    try {\n      // Find all rate limit keys for this identifier using KV list operations\n      let deletedCount = 0;\n      let cursor: string | undefined;\n      let listComplete = false;\n\n      while (!listComplete) {\n        // List keys with pagination (using fixed KV prefix)\n        const listResult = await kv.list({ prefix: KV_KEY_PREFIX, cursor });\n\n        // Filter keys that match this identifier (keys end with :identifier)\n        const keysToDelete = listResult.keys.filter((keyInfo: { name: string }) => keyInfo.name.endsWith(`:${identifier}`)).map((keyInfo: { name: string }) => keyInfo.name);\n\n        // Delete matching keys in batch\n        await Promise.all(keysToDelete.map((key: string) => kv.delete(key)));\n\n        deletedCount += keysToDelete.length;\n\n        // Check if pagination is complete\n        listComplete = listResult.list_complete;\n        cursor = listComplete ? undefined : listResult.keys[listResult.keys.length - 1]?.name;\n      }\n\n      // Return success (void)\n      return;\n    } catch (error) {\n      return err(\n        'Failed to reset rate limit',\n        {\n          identifier,\n          operation: 'resetLimit',\n        },\n        { cause: error }\n      );\n    }\n  },\n};\n",
    "export type { CSRFConfig, CSRFData } from './csrf/@types/csrf.types';\nexport { defaultCSRFConfig } from './csrf/csrf.config';\nexport { useSecureContext } from './csrf/csrf.context';\nexport { createCSRFMiddleware, csrfContext, skipCSRFValidation } from './csrf/csrf.middleware';\nexport { FormError, useFormField } from './csrf/form';\nexport type { SecureFetcherFormProps, SecureFetcherHandle, UseSecureFetcherOptions } from './csrf/SecureFetcher';\nexport { useSecureFetcher } from './csrf/SecureFetcher';\nexport { SecureProvider } from './csrf/SecureProvider';\nexport type { RateLimiterConfig } from './rate-limiter/@types/rate-limiter.types';\nexport { defaultRateLimiterConfig } from './rate-limiter/rate-limiter.config';\nexport { getProviderConfig } from './rate-limiter/rate-limiter.provider';\n\nimport * as SecureFormComponents from './csrf/SecureForm';\nimport { SecureForm as SecureFormComponent } from './csrf/SecureForm';\nexport const SecureForm = Object.assign(SecureFormComponent, {\n  Field: SecureFormComponents.SecureFormField,\n  Error: SecureFormComponents.SecureFormError,\n});\n\nimport * as FormComponents from './csrf/form';\nimport { Form as FormComponent } from './csrf/form';\nexport const Form = Object.assign(FormComponent, {\n  Field: FormComponents.FormField,\n  Error: FormComponents.FormError,\n});\n\nimport * as SecureFetcherComponents from './csrf/SecureFetcher';\nimport { SecureFetcherForm as SecureFetcherFormComponent } from './csrf/SecureFetcher';\nexport const SecureFetcher = Object.assign(SecureFetcherFormComponent, {\n  Field: SecureFetcherComponents.SecureFetcherField,\n  Error: SecureFetcherComponents.SecureFetcherError,\n});\n"
  ],
  "mappings": "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",
  "debugId": "6E12658C94013AA964756E2164756E21",
  "names": []
}