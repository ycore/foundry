{
  "version": 3,
  "sources": ["../../../src/secure/csrf/csrf.ts", "../../../src/secure/csrf/csrf.middleware.ts", "../../../src/secure/headers/secure-headers.middleware.ts", "../../../src/secure/rate-limiter/rate-limiter.middleware.ts", "../../../src/secure/rate-limiter/rate-limiter.provider.ts", "../../../src/secure/rate-limiter/providers/cloudflare-rate-limiter.ts", "../../../src/secure/rate-limiter/providers/kv-rate-limiter.ts", "../../../src/secure/rate-limiter/route-matcher.ts"],
  "sourcesContent": [
    "import { createCookie } from 'react-router';\nimport { CSRF } from 'remix-utils/csrf/server';\n\nimport type { CSRFConfig } from './@types/csrf.types';\n\n/** Creates fresh CSRF instance with config (ensures request isolation) */\nexport function createCSRF(secret: string, config: CSRFConfig): CSRF {\n  const cookie = createCookie(config.cookieName, {\n    path: config.cookie.path,\n    httpOnly: config.cookie.httpOnly,\n    secure: config.cookie.secure,\n    sameSite: config.cookie.sameSite,\n    maxAge: config.cookie.maxAge,\n    secrets: [secret],\n  });\n\n  return new CSRF({\n    cookie,\n    secret,\n    formDataKey: config.formDataKey,\n  });\n}\n",
    "import { logger } from '@ycore/forge/logger';\nimport { middlewarePassthrough } from '@ycore/forge/result';\nimport { getBindings, isDevelopment } from '@ycore/forge/services';\nimport { createContext, type MiddlewareFunction } from 'react-router';\nimport type { CSRFConfig, CSRFData } from './@types/csrf.types';\nimport { createCSRF } from './csrf';\n\n/** CSRF token context for form protection */\nexport const csrfContext = createContext<CSRFData | null>(null);\n\n/** Context to skip CSRF validation for specific requests */\nexport const skipCSRFValidation = createContext<boolean>(false);\n\n/** Creates CSRF commit middleware (GET requests only) */\nexport function createCommitCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    // Only commit CSRF tokens for GET requests to avoid conflicts with validation\n    if (request.method !== 'GET') {\n      return next();\n    }\n\n    const bindings = getBindings(context);\n\n    if (!bindings) {\n      logger.error('csrf_bindings_not_available', { secretKey: config.secretKey });\n      throw new Error('Cloudflare bindings not available - context setup issue');\n    }\n\n    // Access the secret using bracket notation to ensure runtime safety\n    const secret = bindings[config.secretKey as keyof typeof bindings] as string | undefined;\n\n    if (!secret) {\n      logger.error('csrf_secret_not_found', { secretKey: config.secretKey, availableBindings: Object.keys(bindings) });\n      throw new Error(`CSRF secret binding '${config.secretKey}' not found in environment`);\n    }\n\n    // Override secure flag in development\n    const runtimeConfig = {\n      ...config,\n      cookie: {\n        ...config.cookie,\n        secure: isDevelopment(context) ? false : config.cookie.secure,\n      },\n    };\n\n    const csrf = createCSRF(secret, runtimeConfig);\n    const [token, cookieHeader] = await csrf.commitToken();\n\n    // Set both token and config in context\n    const csrfData = { token, formDataKey: config.formDataKey, headerName: config.headerName };\n    context.set(csrfContext, csrfData);\n\n    const response = await next();\n\n    // Add CSRF cookie to response if needed\n    if (cookieHeader) {\n      return middlewarePassthrough(response, {\n        append: { 'Set-Cookie': cookieHeader },\n      });\n    }\n    return response;\n  };\n}\n\n/** Creates CSRF validation middleware (POST/PUT/DELETE/PATCH) */\nexport function createValidateCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    // Only process POST/PUT/DELETE requests\n    if (!['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {\n      return next();\n    }\n\n    // Check and skip CSRF validation for this request\n    const skipCSRF = context.get(skipCSRFValidation);\n    if (skipCSRF) {\n      context.set(skipCSRFValidation, false);\n      return next();\n    }\n\n    const bindings = getBindings(context);\n\n    // Error handling for missing bindings\n    if (!bindings) {\n      logger.error('csrf_bindings_not_available', { secretKey: config.secretKey });\n      throw new Error('Cloudflare bindings not available - context setup issue');\n    }\n\n    // Access the secret using bracket notation to ensure runtime safety\n    const secret = bindings[config.secretKey as keyof typeof bindings] as string | undefined;\n\n    if (!secret) {\n      logger.error('csrf_secret_not_found', { secretKey: config.secretKey, availableBindings: Object.keys(bindings) });\n      throw new Error(`CSRF secret binding '${config.secretKey}' not found in environment`);\n    }\n\n    // Override secure flag in development\n    const runtimeConfig = {\n      ...config,\n      cookie: {\n        ...config.cookie,\n        secure: isDevelopment(context) ? false : config.cookie.secure,\n      },\n    };\n\n    const csrf = createCSRF(secret, runtimeConfig);\n\n    try {\n      // Clone the request to read FormData without consuming original stream\n      const clonedRequest = request.clone();\n      const formData = await clonedRequest.formData();\n\n      await csrf.validate(formData, request.headers);\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Token mismatch';\n      logger.error('csrf_validation_failed', { error: errorMessage, url: request.url });\n\n      throw new Response('Token mismatch', { status: 403, statusText: errorMessage });\n    }\n\n    return next();\n  };\n}\n\n/** Creates complete CSRF middleware (commit + validation) */\nexport function createCSRFMiddleware(config: CSRFConfig): MiddlewareFunction<Response>[] {\n  return [createCommitCSRFMiddleware(config), createValidateCSRFMiddleware(config)];\n}\n",
    "export { unstable_createSecureHeadersMiddleware as secureHeadersMiddleware } from 'remix-utils/middleware/secure-headers';\n\n// export const [secureHeadersMiddleware] = unstable_createSecureHeadersMiddleware();\n",
    "import { logger } from '@ycore/forge/logger';\nimport { getClientIP, isError } from '@ycore/forge/result';\nimport { data, type MiddlewareFunction } from 'react-router';\nimport type { KvProviderConfig, RateLimiterConfig } from './@types/rate-limiter.types';\nimport { checkRateLimit } from './rate-limiter.provider';\nimport { getEffectiveRateLimitConfig } from './route-matcher';\n\n/**\n * Rate limiting middleware with intelligent route-based configuration - throws a 429 response when rate limit exceeded\n */\nexport function rateLimiterMiddleware(config: RateLimiterConfig): MiddlewareFunction<Response> {\n  return async ({ request, context }, next) => {\n    const url = new URL(request.url);\n    const path = url.pathname;\n    const method = request.method;\n\n    // Get effective configuration for this request\n    const effectiveConfig = getEffectiveRateLimitConfig(config, path, method);\n\n    // Skip if no rate limiting should be applied\n    if (!effectiveConfig) {\n      return next();\n    }\n\n    // Create temporary config with effective settings for this request\n    const requestConfig = { ...config, providers: [effectiveConfig.providerConfig] };\n    const clientIP = getClientIP(request) || 'unknown';\n    const rateLimitRequest = { identifier: clientIP, path: path, method: method };\n    const rateLimitResult = await checkRateLimit(requestConfig, rateLimitRequest, context, effectiveConfig.providerId);\n\n    if (isError(rateLimitResult)) {\n      logger.error('Rate limit check (failed open)', { error: rateLimitResult.message });\n      // On error, allow the request through (fail open)\n      return next();\n    }\n\n    const { allowed, remaining, resetAt, retryAfter } = rateLimitResult;\n\n    // Get limit value based on provider type for headers\n    const limitHeader = effectiveConfig.providerConfig.type === 'kv' ? (effectiveConfig.providerConfig as KvProviderConfig).limits.maxRequests.toString() : '100';\n\n    if (!allowed) {\n      logger.warning('Rate limit exceeded', { path: rateLimitRequest.path, remaining, resetAt, retryAfter });\n\n      const headers: HeadersInit = {\n        'X-RateLimit-Limit': limitHeader,\n        'X-RateLimit-Remaining': remaining.toString(),\n        'X-RateLimit-Reset': Math.ceil(resetAt / 1000).toString(),\n      };\n\n      if (retryAfter) {\n        headers['Retry-After'] = retryAfter.toString();\n      }\n\n      // Throw response to ensure proper encoding\n      throw data({ message: 'Too many requests. Please try again later.', retryAfter }, { status: 429, headers });\n    }\n\n    const response = await next();\n\n    if (response instanceof Response) {\n      response.headers.set('X-RateLimit-Limit', limitHeader);\n      response.headers.set('X-RateLimit-Remaining', remaining.toString());\n      response.headers.set('X-RateLimit-Reset', Math.ceil(resetAt / 1000).toString());\n    }\n\n    return response;\n  };\n}\n",
    "import type { Result } from '@ycore/forge/result';\nimport { err, isError } from '@ycore/forge/result';\nimport type { RouterContextProvider } from 'react-router';\nimport type { RateLimiterConfig, RateLimiterProvider, RateLimiterProviderConfig, RateLimitRequest, RateLimitResponse } from './@types/rate-limiter.types';\nimport { cloudflareRateLimiter } from './providers/cloudflare-rate-limiter';\nimport { kvRateLimiter } from './providers/kv-rate-limiter';\n\n/**\n * Provider type registry\n * Maps provider type to implementation\n */\nconst rateLimiterProviders: Record<string, RateLimiterProvider> = {\n  kv: kvRateLimiter,\n  cloudflare: cloudflareRateLimiter,\n};\n\n/**\n * Get all configured provider IDs from config\n */\nfunction getRateLimiterProviderIds(config: RateLimiterConfig): string[] {\n  return config.providers.map(provider => provider.id);\n}\n\n/**\n * Get provider configuration by ID\n */\nexport function getProviderConfig(config: RateLimiterConfig, providerId: string): RateLimiterProviderConfig | null {\n  return config.providers.find(provider => provider.id === providerId) || null;\n}\n\n/**\n * Create a rate limiter provider instance by type\n */\nfunction createRateLimiterProvider(providerType: string): Result<RateLimiterProvider> {\n  const provider = rateLimiterProviders[providerType];\n\n  if (!provider) {\n    const availableProviders = Object.keys(rateLimiterProviders).join(', ');\n    return err(`Unknown rate limiter provider type: ${providerType}. Available: ${availableProviders}`);\n  }\n\n  return provider;\n}\n\n/**\n * Check rate limit using a specific provider (by ID)\n */\nexport async function checkRateLimit(config: RateLimiterConfig, request: RateLimitRequest, context: Readonly<RouterContextProvider>, providerId: string): Promise<Result<RateLimitResponse>> {\n  // Get provider configuration by ID\n  const providerConfig = getProviderConfig(config, providerId);\n  if (!providerConfig) {\n    return err(`Provider configuration not found for ID: ${providerId}`, {\n      providerId: providerId,\n      availableProviders: getRateLimiterProviderIds(config),\n    });\n  }\n\n  // Create provider instance by type\n  const providerResult = createRateLimiterProvider(providerConfig.type);\n  if (isError(providerResult)) {\n    return providerResult;\n  }\n\n  // Execute rate limit check\n  return await providerResult.checkLimit(request, providerConfig, context);\n}\n",
    "import type { Result } from '@ycore/forge/result';\nimport { err } from '@ycore/forge/result';\nimport { getBindings } from '@ycore/forge/services';\nimport type { RouterContextProvider } from 'react-router';\nimport type { CloudflareProviderConfig, CloudflareRateLimiterOptions, RateLimiterProvider, RateLimiterProviderConfig, RateLimitRequest, RateLimitResponse } from '../@types/rate-limiter.types';\n\nconst DEFAULT_WINDOW_MS = 60 * 1000;\n\n/**\n * Type guard for Cloudflare rate limiter options\n */\nfunction isCloudflareRateLimiterOptions(options: unknown): options is CloudflareRateLimiterOptions {\n  return options != null && typeof options === 'object' && 'limiterBinding' in options && typeof (options as CloudflareRateLimiterOptions).limiterBinding === 'string';\n}\n\n/**\n * Cloudflare native rate limiting provider\n *\n * Rate limits are configured in wrangler.jsonc (infrastructure-level), not at runtime.\n *\n * Limitations (inherent to Cloudflare's API):\n * - Only returns success boolean (no granular remaining count)\n * - No built-in reset method (must wait for window expiration)\n * - Rate limits per-Cloudflare location (not globally consistent)\n *\n * @see https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/\n */\nexport const cloudflareRateLimiter: RateLimiterProvider = {\n  name: 'cloudflare',\n\n  async checkLimit(request: RateLimitRequest, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<RateLimitResponse>> {\n    // Type guard: Cloudflare provider config\n    if (config.type !== 'cloudflare') {\n      return err('Invalid provider type for Cloudflare rate limiter', {\n        expectedType: 'cloudflare',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const cfConfig = config as CloudflareProviderConfig;\n\n    // Type guard: Cloudflare rate limiter options\n    if (!isCloudflareRateLimiterOptions(cfConfig.options)) {\n      return err('Cloudflare rate limiter binding not configured', {\n        providerId: cfConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    const cfOptions = cfConfig.options;\n    const bindings = getBindings(context);\n    const rateLimiter = bindings[cfOptions.limiterBinding as keyof typeof bindings] as RateLimit | undefined;\n\n    if (!rateLimiter || typeof rateLimiter.limit !== 'function') {\n      return err(`RateLimit binding '${cfOptions.limiterBinding}' not found in Cloudflare bindings`, {\n        limiterBinding: cfOptions.limiterBinding,\n        providerId: config.id,\n        path: request.path,\n        identifier: request.identifier,\n        availableBindings: Object.keys(bindings),\n      });\n    }\n\n    try {\n      const key = `${request.path}:${request.identifier}`;\n\n      // Call Cloudflare's native rate limiting API\n      const outcome = await rateLimiter.limit({ key });\n\n      // Note: This is for response metadata only - actual limits are in wrangler.jsonc\n      const windowMs = DEFAULT_WINDOW_MS;\n\n      // Map Cloudflare's simple response to our RateLimitResponse interface\n      // Note: Cloudflare only provides success boolean, we approximate other fields\n      const response: RateLimitResponse = {\n        allowed: outcome.success,\n        remaining: outcome.success ? 1 : 0, // Return 1 if allowed (optimistic), 0 if blocked\n        resetAt: Date.now() + windowMs, // Approximate - Cloudflare doesn't expose exact reset time\n        retryAfter: outcome.success ? undefined : Math.ceil(windowMs / 1000), // Provide retryAfter in seconds when rate limited\n      };\n\n      return response;\n    } catch (error) {\n      return err(\n        'Failed to check Cloudflare rate limit',\n        {\n          limiterBinding: cfOptions.limiterBinding,\n          providerId: config.id,\n          key: `${request.path}:${request.identifier}`,\n          path: request.path,\n          identifier: request.identifier,\n        },\n        { cause: error }\n      );\n    }\n  },\n\n  /**\n   * Cloudflare's native Rate Limiting API does not provide a reset method\n   * Rate limits automatically expire based on the configured period\n   */\n  async resetLimit(identifier: string, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<void>> {\n    return err('Cloudflare rate limiter does not support manual reset', {\n      providerId: config.id,\n      identifier,\n      reason: 'Cloudflare Workers Rate Limiting API has no reset method - limits expire automatically based on configured period',\n      workaround: 'Wait for rate limit window to expire naturally, or use KV-based provider which supports resetLimit()',\n    });\n  },\n};\n",
    "import type { Result } from '@ycore/forge/result';\nimport { err } from '@ycore/forge/result';\nimport { getKVStore } from '@ycore/forge/services';\nimport type { RouterContextProvider } from 'react-router';\nimport type { KvProviderConfig, KvRateLimiterOptions, RateLimiterProvider, RateLimiterProviderConfig, RateLimitMetadata, RateLimitRequest, RateLimitResponse } from '../@types/rate-limiter.types';\n\nconst KV_MINIMUM_TTL = 60; // Cloudflare KV minimum TTL in seconds\nconst DEFAULT_RETRY_ATTEMPTS = 3; // Default retries for optimistic locking\nconst RETRY_DELAY_MS = 50; // Base delay between retries\nconst KV_KEY_PREFIX = 'rate_limit'; // Fixed prefix for KV namespace organization\n\nconst rateLimitKvTemplate = (path: string, identifier: string): string => `${KV_KEY_PREFIX}:${path}:${identifier}`;\n\n/**\n * Type guard for KV rate limiter options\n */\nfunction isKvRateLimiterOptions(options: unknown): options is KvRateLimiterOptions {\n  return options != null && typeof options === 'object' && 'kvBinding' in options && typeof (options as KvRateLimiterOptions).kvBinding === 'string';\n}\n\n/**\n * Type guard and validator for rate limit metadata\n */\nfunction isValidRateLimitMetadata(metadata: unknown): metadata is RateLimitMetadata {\n  if (metadata == null || typeof metadata !== 'object') {\n    return false;\n  }\n\n  const meta = metadata as RateLimitMetadata;\n  return typeof meta.count === 'number' && typeof meta.resetAt === 'number' && typeof meta.version === 'number' && meta.count >= 0 && meta.resetAt > 0 && meta.version >= 0;\n}\n\nexport const kvRateLimiter: RateLimiterProvider = {\n  name: 'kv',\n\n  async checkLimit(request: RateLimitRequest, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<RateLimitResponse>> {\n    // Type guard: Ensure this is a KV provider config\n    if (config.type !== 'kv') {\n      return err('Invalid provider type for KV rate limiter', {\n        expectedType: 'kv',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const kvConfig = config as KvProviderConfig;\n\n    // Validate KV binding configuration\n    if (!isKvRateLimiterOptions(kvConfig.options)) {\n      return err('KV binding not configured for rate limiting', {\n        providerId: kvConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    const kvOptions = kvConfig.options;\n\n    // Get the KV namespace from context using the configured binding\n    const kv = getKVStore(context, kvOptions.kvBinding);\n\n    if (!kv) {\n      return err(`KV namespace '${kvOptions.kvBinding}' not found in bindings`, {\n        kvBinding: kvOptions.kvBinding,\n        providerId: kvConfig.id,\n        path: request.path,\n        identifier: request.identifier,\n      });\n    }\n\n    // Extract limits from provider config\n    const maxRequests = kvConfig.limits.maxRequests;\n    const windowMs = kvConfig.limits.windowMs;\n    const maxRetries = kvConfig.behavior?.optimisticLockRetries ?? DEFAULT_RETRY_ATTEMPTS;\n\n    const key = rateLimitKvTemplate(request.path, request.identifier);\n    const now = Date.now();\n\n    /*\n     * IMPORTANT: KV-based rate limiting has inherent race condition risks\n     *\n     * Cloudflare KV is eventually consistent and does not support atomic operations.\n     * This implementation uses optimistic locking (version field) to reduce the race\n     * condition window from ~50ms to ~5ms, but cannot eliminate it completely.\n     *\n     * Current mitigation: Retry with version checking (best effort)\n     */\n\n    try {\n      let attempt = 0;\n      let lastError: Error | null = null;\n\n      while (attempt < maxRetries) {\n        attempt++;\n\n        try {\n          // Get current rate limit data with metadata\n          const kvValue = await kv.getWithMetadata<RateLimitMetadata>(key);\n          let metadata: RateLimitMetadata;\n          let previousVersion: number;\n\n          if (kvValue.metadata && isValidRateLimitMetadata(kvValue.metadata)) {\n            metadata = kvValue.metadata;\n            previousVersion = metadata.version;\n\n            // Check if window has expired\n            if (now >= metadata.resetAt) {\n              // Reset the window\n              metadata = {\n                count: 1,\n                resetAt: now + windowMs,\n                version: previousVersion + 1,\n              };\n            } else {\n              // Check if already blocked - skip write optimization (if enabled)\n              const skipWriteWhenBlocked = kvConfig.behavior?.skipWriteWhenBlocked ?? true;\n              if (skipWriteWhenBlocked && metadata.count > maxRequests) {\n                // Already exceeded limit, return without incrementing\n                const response: RateLimitResponse = {\n                  allowed: false,\n                  remaining: 0,\n                  resetAt: metadata.resetAt,\n                  retryAfter: Math.ceil((metadata.resetAt - now) / 1000),\n                };\n                return response;\n              }\n\n              // Increment counter\n              metadata = {\n                count: metadata.count + 1,\n                resetAt: metadata.resetAt,\n                version: previousVersion + 1,\n              };\n            }\n          } else {\n            // First request in window OR corrupted data - reset\n            metadata = {\n              count: 1,\n              resetAt: now + windowMs,\n              version: 1,\n            };\n            previousVersion = 0;\n          }\n\n          // Check if limit exceeded\n          const allowed = metadata.count <= maxRequests;\n          const remaining = Math.max(0, maxRequests - metadata.count);\n\n          // Store updated data with TTL using metadata API\n          const calculatedTtl = Math.ceil((metadata.resetAt - now) / 1000);\n          const ttl = Math.max(KV_MINIMUM_TTL, calculatedTtl);\n\n          // Use empty string as value, store data in metadata for performance\n          await kv.put(key, '', {\n            expirationTtl: ttl,\n            metadata: metadata,\n          });\n\n          // Verify version hasn't changed (optimistic locking check)\n          // Note: This is best-effort as KV doesn't guarantee consistency\n          const verifyValue = await kv.getWithMetadata<RateLimitMetadata>(key);\n          if (verifyValue.metadata && isValidRateLimitMetadata(verifyValue.metadata) && verifyValue.metadata.version !== metadata.version && verifyValue.metadata.version !== previousVersion) {\n            // Version conflict detected - retry\n            throw new Error('Version conflict detected - concurrent write');\n          }\n\n          const response: RateLimitResponse = {\n            allowed,\n            remaining,\n            resetAt: metadata.resetAt,\n            retryAfter: allowed ? undefined : Math.ceil((metadata.resetAt - now) / 1000),\n          };\n\n          return response;\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n\n          if (attempt < maxRetries) {\n            // Exponential backoff\n            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY_MS * attempt));\n            continue;\n          }\n\n          // Max retries exceeded\n          throw lastError;\n        }\n      }\n\n      // Should never reach here, but TypeScript needs it\n      throw lastError || new Error('Failed to check rate limit after retries');\n    } catch (error) {\n      return err(\n        'Failed to check rate limit',\n        {\n          key,\n          path: request.path,\n          identifier: request.identifier,\n          maxRequests,\n          windowMs,\n        },\n        { cause: error }\n      );\n    }\n  },\n\n  async resetLimit(identifier: string, config: RateLimiterProviderConfig, context: Readonly<RouterContextProvider>): Promise<Result<void>> {\n    // Type guard: Ensure this is a KV provider config\n    if (config.type !== 'kv') {\n      return err('Invalid provider type for KV rate limiter', {\n        expectedType: 'kv',\n        actualType: config.type,\n        providerId: config.id,\n      });\n    }\n\n    const kvConfig = config as KvProviderConfig;\n\n    // Validate KV binding configuration\n    if (!isKvRateLimiterOptions(kvConfig.options)) {\n      return err('KV binding not configured for rate limiting', {\n        providerId: kvConfig.id,\n        identifier,\n      });\n    }\n\n    const kvOptions = kvConfig.options;\n\n    // Get the KV namespace from context using the configured binding\n    const kv = getKVStore(context, kvOptions.kvBinding);\n\n    if (!kv) {\n      return err(`KV namespace '${kvOptions.kvBinding}' not found in bindings`, {\n        kvBinding: kvOptions.kvBinding,\n        providerId: kvConfig.id,\n        identifier,\n      });\n    }\n\n    try {\n      // Find all rate limit keys for this identifier using KV list operations\n      let deletedCount = 0;\n      let cursor: string | undefined;\n      let listComplete = false;\n\n      while (!listComplete) {\n        // List keys with pagination (using fixed KV prefix)\n        const listResult = await kv.list({ prefix: KV_KEY_PREFIX, cursor });\n\n        // Filter keys that match this identifier (keys end with :identifier)\n        const keysToDelete = listResult.keys.filter((keyInfo: { name: string }) => keyInfo.name.endsWith(`:${identifier}`)).map((keyInfo: { name: string }) => keyInfo.name);\n\n        // Delete matching keys in batch\n        await Promise.all(keysToDelete.map((key: string) => kv.delete(key)));\n\n        deletedCount += keysToDelete.length;\n\n        // Check if pagination is complete\n        listComplete = listResult.list_complete;\n        cursor = listComplete ? undefined : listResult.keys[listResult.keys.length - 1]?.name;\n      }\n\n      // Return success (void)\n      return;\n    } catch (error) {\n      return err(\n        'Failed to reset rate limit',\n        {\n          identifier,\n          operation: 'resetLimit',\n        },\n        { cause: error }\n      );\n    }\n  },\n};\n",
    "import type { RateLimiterConfig, RateLimiterProviderConfig, RouteRateLimitConfig } from './@types/rate-limiter.types';\n\n/**\n * Convert glob pattern to regex for route matching\n */\nfunction globToRegex(pattern: string): RegExp {\n  // First escape special regex characters except * and /\n  const escaped = pattern.replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&');\n  // Then handle wildcards: ** for any depth, * for single segment\n  const regex = escaped\n    .replace(/\\*\\*/g, '___DOUBLE_STAR___') // Temporary placeholder\n    .replace(/\\*/g, '[^/]*') // Single * matches anything except /\n    .replace(/___DOUBLE_STAR___/g, '.*'); // ** matches anything including /\n  return new RegExp(`^${regex}$`);\n}\n\n/**\n * Check if a path matches a route pattern\n */\nfunction matchesRoute(path: string, pattern: string): boolean {\n  if (pattern === path) return true;\n  if (!pattern.includes('*')) return false;\n\n  const regex = globToRegex(pattern);\n  return regex.test(path);\n}\n\n/**\n * Find the most specific route configuration for a given path\n * Returns the route config with the longest matching pattern\n */\nfunction findRouteConfig(path: string, routes: RouteRateLimitConfig[]): RouteRateLimitConfig | null {\n  let bestMatch: RouteRateLimitConfig | null = null;\n  let bestMatchLength = 0;\n\n  for (const route of routes) {\n    if (matchesRoute(path, route.pattern)) {\n      // Prefer more specific patterns (longer non-wildcard parts)\n      const specificityScore = route.pattern.replace(/\\*/g, '').length;\n      if (specificityScore > bestMatchLength) {\n        bestMatch = route;\n        bestMatchLength = specificityScore;\n      }\n    }\n  }\n\n  return bestMatch;\n}\n\n/**\n * Get effective rate limit configuration for a specific request\n *\n * Rate limiting is applied to configured routes, null otherwise.\n */\nexport function getEffectiveRateLimitConfig(config: RateLimiterConfig, path: string, method: string): { providerConfig: RateLimiterProviderConfig; providerId: string; } | null {\n  // Check if path should be skipped entirely\n  if (config.conditions?.skipPaths?.some(skipPath => matchesRoute(path, skipPath))) {\n    return null;\n  }\n\n  // Find route-specific configuration - only explicit routes are rate limited\n  const routeConfig = findRouteConfig(path, config.routes);\n\n  // No matching route = no rate limiting\n  if (!routeConfig) {\n    return null;\n  }\n\n  // Check if method is allowed for this specific route\n  if (routeConfig.methods && !routeConfig.methods.includes(method)) {\n    return null;\n  }\n\n  // Get provider configuration by ID\n  const providerId = routeConfig.provider;\n  const providerConfig = config.providers.find(p => p.id === providerId);\n\n  if (!providerConfig) {\n    // Provider not found - skip rate limiting for safety\n    return null;\n  }\n\n  // Return provider configuration\n  return { providerConfig, providerId };\n}\n"
  ],
  "mappings": "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",
  "debugId": "32CA6613D5C9106A64756E2164756E21",
  "names": []
}